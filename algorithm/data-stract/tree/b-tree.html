<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>B树动画演示</title>
  <style>
    body { font-family: sans-serif; background: #f9f9f9; }
    #tree { margin: 40px auto; display: flex; flex-direction: column; align-items: center; }
    .node {
      display: inline-flex;
      background: #fff;
      border: 2px solid #4a90e2;
      border-radius: 6px;
      margin: 8px 4px;
      padding: 6px 12px;
      min-width: 40px;
      justify-content: center;
      transition: background 0.3s;
    }
    .node.active { background: #ffe082; }
    .children {
      display: flex;
      justify-content: center;
      margin-top: 8px;
    }
    #controls { margin: 20px auto; text-align: center; }
    #log { margin: 20px auto; width: 80%; min-height: 30px; color: #333; }
    input[type="number"] { width: 60px; }
    button { margin: 0 4px; }
  </style>
</head>
<body>
  <h2 style="text-align:center;">B树动画演示</h2>
  <div id="controls">
    <input type="number" id="inputValue" placeholder="插入值">
    <button onclick="startInsert()">插入</button>
    <button onclick="resetTree()">重置</button>
  </div>
  <div id="log"></div>
  <div id="tree"></div>
  <script>
    // 简单B树实现（2阶B树，最小度t=2）
    class BTreeNode {
      constructor(leaf = true) {
        this.keys = [];
        this.children = [];
        this.leaf = leaf;
      }
    }

    class BTree {
      constructor(t = 2) {
        this.t = t;
        this.root = new BTreeNode(true);
      }

      // 动画辅助：记录每步操作
      steps = [];

      insert(k) {
        let r = this.root;
        if (r.keys.length === 2 * this.t - 1) {
          let s = new BTreeNode(false);
          s.children[0] = r;
          this.root = s;
          this.steps.push({ type: 'splitRoot', node: r });
          this.splitChild(s, 0);
          this.insertNonFull(s, k);
        } else {
          this.insertNonFull(r, k);
        }
      }

      insertNonFull(x, k) {
        let i = x.keys.length - 1;
        if (x.leaf) {
          while (i >= 0 && k < x.keys[i]) i--;
          x.keys.splice(i + 1, 0, k);
          this.steps.push({ type: 'insertLeaf', node: x, key: k });
        } else {
          while (i >= 0 && k < x.keys[i]) i--;
          i++;
          this.steps.push({ type: 'descend', node: x, child: i });
          if (x.children[i].keys.length === 2 * this.t - 1) {
            this.steps.push({ type: 'splitChild', node: x, child: i });
            this.splitChild(x, i);
            if (k > x.keys[i]) i++;
          }
          this.insertNonFull(x.children[i], k);
        }
      }

      splitChild(x, i) {
        let t = this.t;
        let y = x.children[i];
        let z = new BTreeNode(y.leaf);
        z.keys = y.keys.splice(t, t - 1);
        let mid = y.keys.splice(t - 1, 1)[0];
        x.keys.splice(i, 0, mid);
        x.children.splice(i + 1, 0, z);
        if (!y.leaf) {
          z.children = y.children.splice(t, t);
        }
      }
    }

    // 动画渲染
    let btree, animating = false;

    function renderTree(node, highlightNode = null) {
      if (!node) return '';
      let html = `<div class="node${node === highlightNode ? ' active' : ''}">${node.keys.join(' | ')}</div>`;
      if (node.children.length) {
        html += `<div class="children">`;
        for (let child of node.children) {
          html += `<div>${renderTree(child, highlightNode)}</div>`;
        }
        html += `</div>`;
      }
      return html;
    }

    function showTree(highlightNode = null) {
      document.getElementById('tree').innerHTML = renderTree(btree.root, highlightNode);
    }

    function log(msg) {
      document.getElementById('log').innerText = msg;
    }

    function resetTree() {
      btree = new BTree(2);
      showTree();
      log('B树已重置。');
    }

    async function animateSteps(steps) {
      animating = true;
      for (let step of steps) {
        switch (step.type) {
          case 'splitRoot':
            log('根节点已满，分裂根节点。');
            showTree(step.node);
            break;
          case 'splitChild':
            log('子节点已满，分裂子节点。');
            showTree(step.node.children[step.child]);
            break;
          case 'descend':
            log('下降到子节点。');
            showTree(step.node.children[step.child]);
            break;
          case 'insertLeaf':
            log(`在叶节点插入 ${step.key}。`);
            showTree(step.node);
            break;
        }
        await new Promise(r => setTimeout(r, 800));
      }
      showTree();
      log('操作完成。');
      animating = false;
    }

    function startInsert() {
      if (animating) return;
      let val = parseInt(document.getElementById('inputValue').value);
      if (isNaN(val)) {
        log('请输入要插入的数字。');
        return;
      }
      btree.steps = [];
      btree.insert(val);
      animateSteps(btree.steps);
    }

    // 初始化
    resetTree();
  </script>
</body>
</html>